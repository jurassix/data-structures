export { default as theme } from './themes/theme'
import { Invert, Split, SplitRight, FullScreenCode } from 'mdx-deck/layouts'
import { Image, Appear, Code } from 'mdx-deck'
import { Box } from 'grid-styled'

import { backgroundColor } from './constants'
import CodeLayout from './layouts/Code'

# CS Basics
## JavaScript Basics
### [Increase understanding through experiments]
---
### Stack
---
export default CodeLayout

```javascript
const stack = new Stack();

stack.push('ü¶Ñ');  // bottom [ü¶Ñ] top
stack.push('ü¶ã');  // bottom [ü¶Ñ, ü¶ã] top
stack.push('üêû');  // bottom [ü¶Ñ, ü¶ã, üêû] top

stack.peek(); // üêû top

stack.pop(); // bottom [ü¶Ñ, ü¶ã] top
stack.pop(); // bottom [ü¶Ñ] top
stack.pop(); // bottom [] top
```
---
export default CodeLayout

```javascript
// last-in first-out (LIFO) 
class Stack {
  constructor() {
    this.list = [];    
  }
  push(item) {
    this.list.push(item);
  }
  pop() {
    return this.list.pop();
  }
  peek() {
    const length = this.list.length;
    return this.list[length - 1];
  }
}
```
---
### In the wild ü¶Å
---
### Reverse a word

```javascript
const stack = new Stack();
const word = 'pumpkin';
Array.from(word).map(c => stack.push(c));

let reversed = '';
while (stack.peek()) {
  reversed += stack.pop();
}

console.log(reversed); // nikpmup
```
---
### Undo + Redo

```javascript
const history = new History();

history.add('ü¶Ñ'); // bottom [ü¶Ñ] top
history.add('ü¶ã'); // bottom [ü¶Ñ, ü¶ã] top
history.add('üêû'); // bottom [ü¶Ñ, ü¶ã, üêû] top

history.undo(); // bottom [ü¶Ñ, ü¶ã] top
history.undo(); // bottom [ü¶Ñ] top

history.add('üê¢'); // bottom [ü¶Ñ, üê¢] top
history.undo(); // bottom [ü¶Ñ] top

history.redo(); // bottom [ü¶Ñ, üê¢] top
history.redo(); // bottom [ü¶Ñ, üê¢, ü¶ã] top
history.redo(); // bottom [ü¶Ñ, üê¢, ü¶ã, üêû] top
```
---
### Undo + Redo

```javascript
class History {
  constructor() {
    this.list = new Stack();
    this.discard = new Stack();
  }

  add(item) {
    this.list.push(item);
  }
  
  undo() {
    const item = this.list.pop();
    this.discard.push(item);
    return item;
  }

  redo() {
    const item = this.discard.pop();
    this.list.push(item);
    return item;
  }
}
```
---
### What is a JavaScript Call Stack?
---
export default CodeLayout

```javascript
const boo  = () => {
  console.log('üëª');
}

const beep = () => {
  console.log('ü§ñ');
}

const beepBoo = () => {
  beep();
  boo();
}

beepBoo();
```
---
### [ Execution Context  fn()  ]
### [ Execution Context  fn()  ]
### [ Execution Context  fn()  ]
### [ Execution Context  fn()  ]
### [ Global Execution Context ]
---
### Each Execution Context has two phases
 - Creation
 - Execution
---
### Global Execution Context

<ol>
  <li style={{textAlign: 'left'}}>Creation Phase
    <ul>
      <li style={{textAlign: 'left'}}>this</li>
      <li style={{textAlign: 'left', color: 'yellow'}}>global/window object</li>
      <li style={{textAlign: 'left'}}>attach functions + arguments + variables to Context</li>
      <li style={{textAlign: 'left'}}>setup memory space for them (heap)</li>
    </ul>  
  </li>
  <li style={{textAlign: 'left'}}>Execution Phase
    <ul>
      <li style={{textAlign: 'left'}}>Execute code line-by-line</li>
    </ul>
  </li>
</ol>
---
### Execution Context fn()

<ol>
  <li style={{textAlign: 'left'}}>Creation Phase
    <ul>
      <li style={{textAlign: 'left'}}>this</li>
      <li style={{textAlign: 'left'}}>attach functions + variables to Context</li>
      <li style={{textAlign: 'left'}}>setup memory space for them (heap)</li>
    </ul>  
  </li>
  <li style={{textAlign: 'left'}}>Execution Phase
    <ul>
      <li style={{textAlign: 'left'}}>Execute code line-by-line</li>
    </ul>
  </li>
</ol>
---
### Function Invocation
- Each function call _pushes_ a new Execution Context on to the Stack
- Creation phase
- Execution Phases
- Once code has finished _pops_ off Execution Stack
- Top of Execution Stack continues Execution Phase
- Only when Execution Stack is empty, other work can begin
---
### Demo
[üëª](https://tylermcginnis.com/javascript-visualizer/?code=function%20boo%28%29%20%7B%0A%20%20console.log%28%27boo%27%29%3B%0A%7D%0A%0Afunction%20beep%28%29%20%7B%0A%20%20console.log%28%27beep%27%29%3B%0A%7D%0A%0Afunction%20beepBoo%28%29%20%7B%0A%20%20beep%28%29%3B%0A%20%20boo%28%29%3B%0A%7D%0A%0AbeepBoo%28%29%3B)
---
### Examine the stack of our code
---
export default CodeLayout

### stack will never empty

```javascript
let counter = 0;
while (true) {
  console.log(counter++);
}
```
---
export default CodeLayout

### stack will grow and eventually overflow

```javascript
const work = () => {
  work();
};

// kick it off!
work();
```
---
export default CodeLayout

### stack will grow and eventually throw

```javascript
let shouldThrow = true;
const work = () => {
  if (shouldThrow) {
    setTimeout(() => { throw new Error('setTimeout üòà'); }, 0);
    shouldThrow = false;
  }
  work();
};

// kick it off!
work();
```
---
### Queue
---
export default CodeLayout

```javascript
const queue = new Queue();

queue.enqueue('ü¶Ñ');  // front [ü¶Ñ] end
queue.enqueue('ü¶ã');  // front [ü¶Ñ, ü¶ã] end
queue.enqueue('üêû');  // front [ü¶Ñ, ü¶ã, üêû] end

queue.peek(); // ü¶Ñ front

queue.dequeue(); // front [ü¶ã, üêû] end
queue.dequeue(); // front [üêû] end
queue.dequeue(); // front [] end
```
---
export default CodeLayout

```javascript
// first-in first-out (FIFO) 
class Queue {
  constructor() {
    this.list = [];    
  }
  enqueue(item) {
    this.list.push(item);
  }
  dequeue() {
    return this.list.shift();
  }
  peek() {
    return this.list[0];
  }
}
```
---
### What is a JavaScript Event Loop?
---
### Event Loop
Call Stack + Callback Queue
---
### Think about the call stack

```javascript
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].forEach(item => {
  console.log(item);
  setTimeout(() => {
    console.log(`${item} üòà`);
  }, 0);
});

// our stack is clear now
// callback queue now has 10 items enqueued
// each is handled in order
```
---
### Event Loop is the exchange between call stack and event queue
---
### Sets + Maps
---
export default CodeLayout

```javascript

const group1 = ['Lucy', 'Amelia', 'Miller', 'Jody'];
const group2 = ['Gail', 'Sally', 'Marlyn', 'Jody'];

// includes 'Jody' twice
const all = [...group1, ...group2];

// how to remove duplicates???

```
---
### The Set data structure stores unique values
---
```javascript
const set = new Set();

set.add('ü¶ï'); // Set [ 'ü¶ï' ]
set.add('ü¶ñ'); // Set [ 'ü¶ï', 'ü¶ñ' ]
set.add('ü¶ñ'); // Set [ 'ü¶ï', 'ü¶ñ' ]

set.has('ü¶ï'); // true
set.has('üî•'); // false

set.size; // 2

set.delete('ü¶ñ'); // removes ü¶ñ from the set

// iterable
for (let item of set) console.log(item); // 'ü¶ï'
```
---
export default CodeLayout

```javascript
const set = new Set();

// objects use referential equality (===)

set.add({ a: 1 }); // Set [ {a: 1} ]
set.add({ a: 1 }); // Set [ {a: 1}, {a: 1} ]

const b = { b: 2 };
set.add(b); // Set [ {a: 1}, {a: 1}, {b: 2} ]
set.add(b); // Set [ {a: 1}, {a: 1}, {b: 2} ]
```
---
export default CodeLayout

```javascript
// store only unique values
class Set {
  constructor() {
    this.list = [];
  }
  get size() {
    return this.list.length;
  }
  add(item) {
    if (!this.has(item)) {
      this.list.push(item);
    }
  }
  has(item) {
    return this.list.includes(item);
  }
  delete(item) {
    const index = this.list.indexOf(item);
    if (index !== -1) {
      delete this.list[index];
    }
  }
}
```
---
### Please don't write your own Set üòò
### It's built in
---
### WeakSet
- Only store _object_ data types
- No iteration: has, add, delete
---
### WeakSet can be GC'd
```javascript
const set = new WeakSet();

set.add({}).add({});
```
---
export default CodeLayout

### Limitations with objects

```javascript

const key = { 
  name: 'Lucy', 
  age: 4, 
  location: 'Atlanta'
};

const map = { 
  [key]: 'child' 
};

// { [object Object]: 'child' }
```
---
### The Map data structure holds key-value pairs, and supports objects as keys.
---
```javascript
const map = new Map();

const string = 'key';
const object = {};
const fn = function() {};

// setting the values
map.set(string, 'string value');
map.set(object, 'object value');
map.set(fn, 'fn value');

map.has(fn) // true

// Map(3)¬†{
//   "key" => "string value",
//   {} => "object value",
//   ∆í => "fn value"
// }
```
---
export default CodeLayout

```javascript
// store any data type as keys [list of lists]
class Map {
  constructor() {
    this.list = [];
  }
  set(key, value) {
    if (!this.has(key)) {
      this.list.push([key, value]);
    }
  }
  get(key) {
    const item = this.list.find(([k, v]) => k === key);
    if (item) {
      return item.value;
    }
  }
  has(key) {
    return this.list.some(([k, v]) => k === key);
  }
  delete(key) {
    const index = this.list.findIndex(([k, v]) => k === key);
    if (index !== -1) {
      delete this.list[index];
    }
  }
}
```
---
### Please don't write your own Map üòò
### It's built in
---
### WeakMap
- Only store _object_ data types
- No iteration: has, get, set, delete
---
### WeakMap can be GC'd
```javascript
const map = new WeakMap();

map.set({}, 'value').set({}, 'another value');
```
---
### Trees
---
export default CodeLayout

### HTML is hierarchical

```javascript
<section>
  <h2>üêØ</h2>
  <p>ü¶Å</p>
  <em>
    <h1>üêÆ</h1>
    <p>üê∑</p>
  </em>
</section>
```
---
### We use trees to model hierarchical data
---
export default CodeLayout

```javascript
class Node {
  constructor(value, children) {
    this.value = value;
    this.children = Array.isArray(children) ? children : [];
  }
}
```
---
export default CodeLayout

```javascript
class Tree {
  constructor() {
    this.root = null;
  }
  add(value, parentValue) {
    const child = new Node(value, []);
    if (this.root == null) {
      this.root = child;
    } else {    
      traverse(node => {
        if (node.value === parentValue) {
          node.children.push(child)
        }
      });
    }
  }
  traverse(callback) {
    
  }
}
```
---
### We also use trees for searching
---
export default CodeLayout

```javascript

```